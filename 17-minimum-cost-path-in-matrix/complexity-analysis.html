<div class="text-viewer--scroll-container--1iy0Z"><div class="text-viewer--content--3hoqQ"><div class="udlite-heading-xxl text-viewer--main-heading--ZbxZA">Complexity analysis</div><div class="article-asset--container--3djM8"><div data-purpose="safely-set-inner-html:rich-text-viewer:html" class="article-asset--content--1dAQ9 rich-text-viewer--rich-text-viewer--19N-I"><p><strong>Solution 1:</strong></p><p>We put n = number of rows</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m = number of columns</p><p><strong>Time complexity:</strong> O(2^(n+m))</p><p><strong>Explanation:</strong></p><p>What we're doing is that we are moving by one cell at each function call, and we're calling the function twice (once to go to the right and once to the bottom)</p><p>So if we put N=n+m that represents the number of cells to go from the top-left cell to the bottom-right cell (the length of a path), then we can write that:</p><p>T(N) = 2T(N-1)+1</p><p>Because we are moving by one cell so the number of remaining cells becomes N-1, we are calling the function twice, this is why we multiplied by 2, and remaining operations in the function call cost O(1)</p><p>We also have T(0) = 1 because in the base case we just return the value of a cell</p><p>Let's use the recurrence relation method:</p><p>T(N) = 2(2T(N-2)+1)+1</p><p>T(N) = 4T(N-2) + 3</p><p>T(N) = 4(2T(N-3)+1)+3</p><p>T(N) = 8T(N-3) + 7</p><p>T(N) = 8(2T(N-4)+1)+7</p><p>T(N) = 16T(N-4) + 15</p><p>T(N) = 16(2T(N-5)+1)+15</p><p>T(N) = 32T(N-5) + 31</p><p>.</p><p>.</p><p>T(N) = (2^k)T(N-k) + (2^k)-1</p><p>.</p><p>.</p><p>T(N) = (2^N)T(N-N) + (2^N)-1</p><p>T(N) = (2^N)T(0) + (2^N)-1</p><p>T(N) = (2^N) + (2^N)-1</p><p>T(N) = 2(2^N)-1</p><p>T(N) = O(2^N)</p><p>We know that N=n+m, so we replace and we get an O(2^(n+m)) time complexity</p><p><strong>Bonus info:</strong> why we've put N=n+m and not N=n*m? It's because we can only move to the right or to the bottom, so the length of a path between the top-left cell and the bottom-right cell is n+m</p><p><strong>Space complexity:</strong> O(n+m)</p><p><strong>Explanation:</strong></p><p>We are not using input-size related variables, but we have the call stack size, and the call stack size depends on the depth of the recursion tree</p><p>Here we are moving by one cell at each recursive call, and the length of the path to go from the top-left cell to the bottom-right cell is n+m, so the space complexity is O(n+m)</p><p><br></p><p><strong>Solution 2:</strong></p><p>We put n = number of rows</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m = number of columns</p><p><strong>Time complexity:</strong> O(n*m)</p><p><strong>Explanation:</strong></p><p>We are traversing a matrix of size n*m, the time complexity is O(n*m)</p><p><strong>Space complexity:</strong> O(n*m)</p><p><strong>Explanation:</strong></p><p>We are using an extra matrix of size n*m, the dp matrix, the space complexity is O(n*m)</p></div></div></div></div>
