<div class="text-viewer--scroll-container--1iy0Z"><div class="text-viewer--content--3hoqQ"><div class="udlite-heading-xxl text-viewer--main-heading--ZbxZA">Complexity analysis</div><div class="article-asset--container--3djM8"><div data-purpose="safely-set-inner-html:rich-text-viewer:html" class="article-asset--content--1dAQ9 rich-text-viewer--rich-text-viewer--19N-I"><p><strong>Solution 1:</strong></p><p>We put n = length of values = length of weights</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;w = maxWeight</p><p><strong>Time complexity:</strong> O(2^n)</p><p><strong>Explanation:</strong></p><p>We will use the recurrence relation method</p><p>In the base case, when n is equal to 0, we just return 0, so</p><p>T(0,w) = 1</p><p>In the worst recursive case, we recursively call the function twice starting from the next element, and remaining stuff is O(1), so</p><p>T(n,w) = 2T(n-1,w)+1</p><p>We keep replacing:</p><p>T(n,w) = 2(2T(n-2,w)+1)+1</p><p>T(n,w) = 4T(n-2,w) + 3</p><p>T(n,w) = 4(2T(n-3,w)+1)+3</p><p>T(n,w) = 8T(n-3,w) + 7</p><p>T(n,w) = 8(2T(n-4,w)+1)+7</p><p>T(n,w) = 16T(n-4,w) + 15</p><p>T(n,w) = 16(2T(n-5,w)+1)+15</p><p>T(n,w) = 32T(n-5,w) + 31<br>.<br>.</p><p>T(n,w) = (2^k)T(n-k,w) + (2^k)-1<br>.<br>.</p><p>T(n,w) = (2^n)T(n-n,w) + (2^n)-1</p><p>T(n,w) = (2^n)T(0,w) + (2^n)-1</p><p>T(n,w) = (2^n) + (2^n)-1</p><p>T(n,w) = 2(2^n)-1</p><p>T(n,w) = O(2^n)</p><p><strong>Space complexity:</strong> O(n)</p><p><strong>Explanation:</strong></p><p>The maximum call stack size is n+1 because we jump by 1 position in the array only at each level (0, 1, ..., n-1, n)</p><p>S(n) = n+1 = O(n)</p><p><br></p><p><strong>Solution 2:</strong></p><p>We put n = length of values = length of weights</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;w = maxWeight</p><p><strong>Time complexity:</strong> O(nw)</p><p><strong>Explanation:</strong></p><p>In our memoization table, a key is made of the couple (i, w), and the number of possible values of i is n (0, 1, ..., n-1), the number of possible values of w is w (0, 1, ..., w-1), so the number of possible keys is n*w</p><p>And in memoization, each possibility is computed once, the cost is O(1) in our case, so:</p><p>T(n,w) = n*w*O(1) = O(nw)</p><p><strong>Space complexity: </strong>O(nw)</p><p><strong>Explanation:</strong></p><p>We said that our memoization table contains at most n*w keys</p><p>S(n,w) = n*w = O(nw)</p></div></div></div></div>
