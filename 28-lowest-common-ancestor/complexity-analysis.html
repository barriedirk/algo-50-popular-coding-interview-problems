<div class="text-viewer--scroll-container--1iy0Z"><div class="text-viewer--content--3hoqQ"><div class="udlite-heading-xxl text-viewer--main-heading--ZbxZA">Complexity analysis</div><div class="article-asset--container--3djM8"><div data-purpose="safely-set-inner-html:rich-text-viewer:html" class="article-asset--content--1dAQ9 rich-text-viewer--rich-text-viewer--19N-I"><p><strong>Solution 1:</strong></p><p>We put n = number of nodes in the tree</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h = height of the tree</p><p><strong>Time complexity:</strong> O(n)</p><p><strong>Explanation:</strong></p><p>The getPath() function has an O(n) cost because it searches the whole tree</p><p>We are calling it twice then traversing the paths, and traversing a path has an O(h) cost because a path has one node from each level</p><p>T(n) = 2n+h, and because h can't be greater than n, then we can replace h by n, we get:</p><p>T(n) = 2n+n = 3n = O(n)</p><p><strong>Space complexity: </strong>O(h)</p><p><strong>Explanation:</strong></p><p>The maximum call stack size depends on the height of the tree, and we are creating two path arrays where each path can contain h elements</p><p>S(n) = h+h+h = 3h = O(h)</p><p><br></p><p><strong>Solution 2:</strong></p><p>We put n = number of nodes in the tree</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h = height of the tree</p><p><strong>Time complexity:</strong> O(n)</p><p><strong>Explanation:</strong></p><p>We are just traversing the n nodes of the tree while doing O(1) operations</p><p>T(n) = n*O(1) = O(n)</p><p><strong>Space complexity:</strong> O(h)</p><p><strong>Explanation:</strong></p><p>The maximum call stack size depends on the height of the tree</p></div></div></div></div>
