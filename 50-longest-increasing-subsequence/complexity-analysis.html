<div class="text-viewer--scroll-container--1iy0Z"><div class="text-viewer--content--3hoqQ"><div class="udlite-heading-xxl text-viewer--main-heading--ZbxZA">Complexity analysis</div><div class="article-asset--container--3djM8"><div data-purpose="safely-set-inner-html:rich-text-viewer:html" class="article-asset--content--1dAQ9 rich-text-viewer--rich-text-viewer--19N-I"><p><strong>Solution 1:</strong></p><p>We put n = length of arr</p><p><strong>Time complexity: </strong>O(2^n)</p><p><strong>Explanation:</strong></p><p>We will use the recurrence relation method</p><p>In the base case, when n is equal to 0, we just return an integer, so</p><p>T(0) = 1</p><p>In the worst recursive case, we recursively call the function twice starting from the next element, and remaining stuff is O(1), so</p><p>T(n) = 2T(n-1)+1</p><p>We keep replacing:</p><p>T(n) = 2(2T(n-2)+1)+1</p><p>T(n) = 4T(n-2) + 3</p><p>T(n) = 4(2T(n-3)+1)+3</p><p>T(n) = 8T(n-3) + 7</p><p>T(n) = 8(2T(n-4)+1)+7</p><p>T(n) = 16T(n-4) + 15</p><p>T(n) = 16(2T(n-5)+1)+15</p><p>T(n) = 32T(n-5) + 31<br>.<br>.</p><p>T(n) = (2^k)T(n-k) + (2^k)-1<br>.<br>.</p><p>T(n) = (2^n)T(n-n) + (2^n)-1</p><p>T(n) = (2^n)T(0) + (2^n)-1</p><p>T(n) = (2^n) + (2^n)-1</p><p>T(n) = 2(2^n)-1</p><p>T(n) = O(2^n)</p><p><strong>Space complexity:</strong> O(n)</p><p><strong>Explanation:</strong></p><p>The maximum call stack size is n+1 because we jump by 1 position in the array only at each level (0, 1, ..., n-1, n)</p><p>S(n) = n+1 = O(n)</p><p><br></p><p><strong>Solution 2:</strong></p><p>We put n = length of arr</p><p><strong>Time complexity:</strong> O(n²)</p><p><strong>Explanation:</strong></p><p>The outer loop does n iterations, and the inner loop does i iterations, remaining stuff has an O(1) cost</p><p>Cost of iterations of the outer loop:</p><p>1st iteration -&gt; i = 0 </p><p>2nd iteration -&gt; i = 1</p><p>3rd iteration -&gt; i = 2 </p><p>.</p><p>.</p><p>nth iteration -&gt; i = n-1 </p><p>The sum is 0+1+2+...+(n-1), it's the sum of integers from 0 to n-1, which is equal to n(n-1)/2</p><p>T(n) = n(n-1)/2 = (n²-n)/2 = n²/2 - n/2, we take the greatest term, we remove the constant, and we get a time complexity of O(n²)</p><p><strong>Space complexity:</strong> O(n)</p><p><strong>Explanation:</strong></p><p>We're using an extra array dp of n elements</p><p><br></p><p><strong>Solution 3:</strong></p><p>We put n = length of arr</p><p><strong>Time complexity:</strong> O(nlogn)</p><p><strong>Explanation:</strong></p><p>The ceilIndex() function is similar to binary search, it has an O(logn) time complexity because we keep dividing the input size by 2</p><p>In the lis() function, we traverse elements of arr starting from the index i while calling the ceilIndex() function</p><p>T(n) = (n-1)*O(logn) = O(nlogn)</p><p><strong>Space complexity:</strong> O(n)</p><p><strong>Explanation:</strong></p><p>We're using an extra array subsequence that contains up to n elements</p></div></div></div></div>
