<div class="text-viewer--scroll-container--1iy0Z"><div class="text-viewer--content--3hoqQ"><div class="udlite-heading-xxl text-viewer--main-heading--ZbxZA">Complexity analysis</div><div class="article-asset--container--3djM8"><div data-purpose="safely-set-inner-html:rich-text-viewer:html" class="article-asset--content--1dAQ9 rich-text-viewer--rich-text-viewer--19N-I"><p><strong>Solution 1:</strong></p><p>We put n = length of str1</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m = length of str2</p><p><strong>Time complexity:</strong> O(3^(n+m))</p><p><strong>Explanation:</strong></p><p>What we're doing is that we are moving by one character at each function call, and we're calling the function thrice (once to move on str1 only, once to move on str2 only, and once to move on both of them)</p><p>So if we put N=n+m that represents the length of the concatenation of str1 and str2, we can write that:</p><p>T(N) = 3T(N-1)+1</p><p>Because we are moving by one character in one of them, so the number of remaining characters becomes N-1, we are calling the function thrice, this is why we multiplied by 3, and remaining operations in the function call cost O(1)</p><p>We also have T(0) = 1 because in the base case we just return an integer</p><p>Let's use the recurrence relation method:</p><p>T(N) = 3(3T(N-2)+1)+1</p><p>T(N) = 9T(N-2) + 4</p><p>T(N) = 9(3T(N-3)+1)+4</p><p>T(N) = 27T(N-3) + 13</p><p>T(N) = 27(3T(N-4)+1)+13</p><p>T(N) = 81T(N-4) + 40</p><p>T(N) = 81(3T(N-5)+1)+40</p><p>T(N) = 243T(N-5) + 121</p><p>.</p><p>.</p><p>T(N) = (3^k)T(N-k) + (3^k)/2 - 1</p><p>.</p><p>.</p><p>T(N) = (3^N)T(N-N) + (3^N)/2 - 1</p><p>T(N) = (3^N)T(0) + (3^N)/2 - 1</p><p>T(N) = (3^N) + (3^N)/2 - 1</p><p>T(N) = 3/2(3^N)-1</p><p>T(N) = O(3^N)</p><p>We know that N=n+m, so we replace and we get an O(3^(n+m)) time complexity</p><p><strong>Space complexity: </strong>O(n+m)</p><p><strong>Explanation:</strong></p><p>We are not using input-size related variables, but we have the call stack, and the call stack size depends on the depth of the recursion tree</p><p>Here we are moving by one character in one of them at each recursive call, this is why we need a depth of n+m to reach the end of both of them, the space complexity is O(n+m)<br></p><p><strong>Solution 2:</strong></p><p>We put n = number of rows</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m = number of columns</p><p><strong>Time complexity: </strong>O(n*m)</p><p><strong>Explanation:</strong></p><p>We are traversing a matrix of size (n+1)*(m+1)</p><p>T(n,m) = (n+1)*(m+1) = nm + n + m + 1 = O(nm)</p><p><strong>Space complexity:</strong> O(n*m)</p><p><strong>Explanation:</strong></p><p>We are using an extra matrix of size (n+1)*(m+1), the dp matrix</p><p>S(n,m) = (n+1)*(m+1) = nm + n + m + 1 = O(nm)</p></div></div></div></div>
