<div class="text-viewer--scroll-container--1iy0Z"><div class="text-viewer--content--3hoqQ"><div class="udlite-heading-xxl text-viewer--main-heading--ZbxZA">Complexity analysis</div><div class="article-asset--container--3djM8"><div data-purpose="safely-set-inner-html:rich-text-viewer:html" class="article-asset--content--1dAQ9 rich-text-viewer--rich-text-viewer--19N-I"><p><strong>Solution 1:</strong></p><p>We put n = the number of nodes in the linked list</p><p><strong>Time complexity:</strong> O(n²)</p><p><strong>Explanation:</strong></p><p>i starts at the head and we keep looping until it becomes null, so it will traverse all the nodes, the outer while loop does n iterations</p><p>j starts at the head and we keep looping until its next node becomes null, so it will traverse all the nodes except the last one, the inner loop does n-1 iterations</p><p>What's inside the inner loop costs O(1), we get:</p><p>T(n) = n(n-1) = n²-n = O(n²)</p><p><strong>Space complexity:</strong> O(1)</p><p><strong>Explanation:</strong></p><p>We're just using variables i and j</p><p>S(n) = 2 = O(1)</p><p><br></p><p><strong>Solution 2:</strong></p><p>We put n = the number of nodes in the linked list</p><p><strong>Time complexity:</strong> O(nlogn)</p><p><strong>Explanation:</strong></p><p>The mergeSortedLists() function costs O(n) where n is the length of the longest linked list passed as a parameter</p><p>In the base case, we just return the head, so we write: T(0) = 1</p><p>In the recursive case, the first while loop traverses the linked list but fast jumps by 2 nodes at a time, so we do n/2 iterations. We also have the cost of the mergeSortedLists() function that we called to merge our left and right half. A half of the linked list has n/2 nodes, so the function call costs n/2. And we also recursively call the mergeSort() function twice on the left and right half, they have n/2 nodes each. We write: T(n) = 2T(n/2) + n/2 + n/2 = 2T(n/2) + n</p><p>Now we use the Master method</p><figure><img src="https://img-b.udemycdn.com/redactor/raw/article_lecture/2021-03-17_07-57-05-f8ceb3f3fbe14247bfad8ac4974a3571.png?secure=WspKMB-tcrR_mZtHMHprDw%3D%3D%2C1644889968" width="309" height="198" align="middle"></figure><p>Here a is 2, b is 2, log_b(a) is log_2(2) which is 1, f(n) is n which is (n^1)*(logn^0), c is 1, and d is 0</p><p>c is equal to log_b(a) and d &gt; -1 so T(n) = O((n^c)*(logn^(d+1))) which is O(nlogn)</p><p><strong>Space complexity: </strong>O(logn)</p><p><strong>Explanation:</strong></p><p>A recursive call isn't using input-size related extra space but the call stack size is in O(logn) because we are dividing the input size by 2 at each call, so:</p><p>S(n) = O(logn)</p></div></div></div></div>
