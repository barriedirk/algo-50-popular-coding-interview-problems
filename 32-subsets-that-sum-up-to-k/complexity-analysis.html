<div class="text-viewer--scroll-container--1iy0Z"><div class="text-viewer--content--3hoqQ"><div class="udlite-heading-xxl text-viewer--main-heading--ZbxZA">Complexity analysis</div><div class="article-asset--container--3djM8"><div data-purpose="safely-set-inner-html:rich-text-viewer:html" class="article-asset--content--1dAQ9 rich-text-viewer--rich-text-viewer--19N-I"><p><strong>Solution 1:</strong></p><p>We put n = length of arr</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;k = the sum we're searching for</p><p><strong>Time complexity:</strong> O(2^n)</p><p><strong>Explanation:</strong></p><p>We will use the recurrence relation method</p><p>In the base case, when n is equal to 0, we just return an integer, so</p><p>T(0,k) = 1</p><p>In the recursive case, we recursively call the function twice starting from the next character, and remaining stuff is O(1), so</p><p>T(n,k) = 2T(n-1,k)+1</p><p>We keep replacing:</p><p>T(n,k) = 2(2T(n-2,k)+1)+1</p><p>T(n,k) = 4T(n-2,k) + 3</p><p>T(n,k) = 4(2T(n-3,k)+1)+3</p><p>T(n,k) = 8T(n-3,k) + 7</p><p>T(n,k) = 8(2T(n-4,k)+1)+7</p><p>T(n,k) = 16T(n-4,k) + 15</p><p>T(n,k) = 16(2T(n-5,k)+1)+15</p><p>T(n,k) = 32T(n-5,k) + 31</p><p>.</p><p>.</p><p>T(n,k) = (2^K)T(n-K,k) + (2^K)-1</p><p>.</p><p>.</p><p>T(n,k) = (2^n)T(n-n,k) + (2^n)-1</p><p>T(n,k) = (2^n)T(0,k) + (2^n)-1</p><p>T(n,k) = (2^n) + (2^n)-1</p><p>T(n,k) = 2(2^n)-1</p><p>T(n,k) = O(2^n)</p><p><strong>Space complexity:</strong> O(n)</p><p><strong>Explanation:</strong></p><p>The maximum call stack size is n+1 because we jump by 1 position in the array only at each level (0, 1, ..., n-1, n)</p><p>S(n,k) = n+1 = O(n)</p><p><br></p><p><strong>Solution 2:</strong></p><p>We put n = length of arr</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k = the sum we're searching for</p><p><strong>Time complexity:</strong> O(nk)</p><p><strong>Explanation:</strong></p><p>In our memoization table, a key is made of the couple (i, sum), and the number of possible values of i is n (0, 1, ..., n-1), the number of possible values of sum is k (0, 1, ..., k-1), so the number of possible keys is n*k</p><p>And in memoization, each possibility is computed once, the cost is O(1) in our case, so:</p><p>T(n,k) = n*k*O(1) = O(nk)</p><p><strong>Space complexity:</strong> O(nk)</p><p><strong>Explanation:</strong></p><p>We said that our memoization table contains at most n*k keys</p><p>S(n,k) = n*k = O(nk)</p></div></div></div></div>
