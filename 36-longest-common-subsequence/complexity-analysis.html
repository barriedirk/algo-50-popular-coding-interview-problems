<div class="text-viewer--scroll-container--1iy0Z"><div class="text-viewer--content--3hoqQ"><div class="udlite-heading-xxl text-viewer--main-heading--ZbxZA">Complexity analysis</div><div class="article-asset--container--3djM8"><div data-purpose="safely-set-inner-html:rich-text-viewer:html" class="article-asset--content--1dAQ9 rich-text-viewer--rich-text-viewer--19N-I"><p><strong>Solution 1:</strong></p><p>We put n = length of str1</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m = length of str2</p><p><strong>Time complexity:</strong> O((n+m).2^n)</p><p><strong>Explanation:</strong></p><p>Checking if a string of size n is a subsequence of a string of size m costs O(m) because we may need to traverse the whole m-length string</p><p>Generating the subsequences of str1 costs O(n.2^n)</p><p>We are traversing the 2^n subsequences of str1, and for each one of them, we are checking if it's a subsequence of str2, which costs O(m) as mentioned earlier</p><p>Total:</p><p>T(n) = O(n.2^n) + (2^n)*O(m) = O(n.2^n) + O(m.2^n) = O((n+m).2^n)</p><p><strong>Space complexity:</strong> O(n.2^n)</p><p><strong>Explanation:</strong></p><p>The cost of storing the 2^n subsequences of str1 is in O(n.2^n)</p><p><br></p><p><strong>Solution 2:</strong></p><p>We put n = length of str1</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m = length of str2</p><p><strong>Time complexity:</strong> O(2^(n+m))</p><p><strong>Explanation:</strong></p><p>What we're doing is that we are moving by one character at each function call, and we're calling the function twice (once to move on str1 and once to move on str2)</p><p>So if we put N=n+m that represents the length of the concatenation of str1 and str2, we can write that:</p><p>T(N) = 2T(N-1)+1</p><p>Because we are moving by one character in one of them, so the number of remaining characters becomes N-1, we are calling the function twice, this is why we multiplied by 2, and remaining operations in the function call cost O(1)</p><p>We also have T(0) = 1 because in the base case we just return 0</p><p>Let's use the recurrence relation method:</p><p>T(N) = 2(2T(N-2)+1)+1</p><p>T(N) = 4T(N-2) + 3</p><p>T(N) = 4(2T(N-3)+1)+3</p><p>T(N) = 8T(N-3) + 7</p><p>T(N) = 8(2T(N-4)+1)+7</p><p>T(N) = 16T(N-4) + 15</p><p>T(N) = 16(2T(N-5)+1)+15</p><p>T(N) = 32T(N-5) + 31</p><p>.</p><p>.</p><p>T(N) = (2^k)T(N-k) + (2^k)-1</p><p>.</p><p>.</p><p>T(N) = (2^N)T(N-N) + (2^N)-1</p><p>T(N) = (2^N)T(0) + (2^N)-1</p><p>T(N) = (2^N) + (2^N)-1</p><p>T(N) = 2(2^N)-1</p><p>T(N) = O(2^N)</p><p>We know that N=n+m, so we replace and we get an O(2^(n+m)) time complexity</p><p><strong>Space complexity: </strong>O(n+m)</p><p><strong>Explanation:</strong></p><p>We are not using input-size related variables, but we have the call stack, and the call stack size depends on the depth of the recursion tree</p><p>Here we are moving by one character in one of them at each recursive call, this is why we need a depth of n+m to reach the end of both of them, the space complexity is O(n+m)</p><p><br></p><p><strong>Solution 3:</strong></p><p>We put n = length of str1</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; k = length of str2</p><p><strong>Time complexity:</strong> O(nm)</p><p><strong>Explanation:</strong></p><p>In our memoization table, a key is made of the couple (i, j), and the number of possible values of i is n (0, 1, ..., n-1), the number of possible values of j is m (0, 1, ..., m-1), so the number of possible keys is n*m</p><p>And in memoization, each possibility is computed once, the cost is O(1) in our case, so:</p><p>T(n,m) = n*m*O(1) = O(nm)</p><p><strong>Space complexity:</strong> O(nm)</p><p><strong>Explanation:</strong></p><p>We said that our memoization table contains at most n*m keys</p><p>S(n,m) = n*m = O(nm)</p><p><br></p><p><strong>Solution 4:</strong></p><p>We put n = number of rows</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m = number of columns</p><p><strong>Time complexity:</strong> O(n*m)</p><p><strong>Explanation:</strong></p><p>We are traversing a matrix of size n*m, the time complexity is O(n*m)</p><p><strong>Space complexity:</strong> O(n*m)</p><p><strong>Explanation:</strong></p><p>We are using an extra matrix of size (n+1)*(m+1), the dp matrix</p><p>S(n,m) = (n+1)*(m+1) = nm + n + m + 1 = O(nm)</p><p><br></p><p><strong>Solution 5:</strong></p><p>We put n = number of rows</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m = number of columns</p><p><strong>Time complexity:</strong> O(n*m)</p><p><strong>Explanation:</strong></p><p>The outer loop is doing n iterations</p><p>The inner loops are both doing m iterations</p><p>T(n,m) = n(m+m) = n*2m = 2nm = O(nm)</p><p><strong>Space complexity:</strong> O(m)</p><p><strong>Explanation:</strong></p><p>We are using two arrays of m+1 elements</p><p>S(n,m) = 2(m+1) = 2m+2 = O(m)</p><p>Note that we can optimize more by comparing n and m and deciding if we create two rows of m+1 elements or two columns of n+1 elements, we get a space complexity of O(min(n,m))</p></div></div></div></div>
